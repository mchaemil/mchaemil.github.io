---
layout: article
title: javascript | My Javascript Boot camp 
tags: javascript

---

## **Today What I Learend**  

나름 익숙하다고 생각했던 Javascript에서 새롭게 알게 된 부분을 정리하고, 중요하다고 생각하는 부분을 정리하는 시간을 가졌다.! 
너무 당연한 이야기겠지만..! 아직도 Javascript에 대해 자세히 모르는 부분이 많았다.
덕분에 조금은 더 자바스크립트를 보는 시야가 넓어진 것 같다..! 이것에 익숙해지기 위해서 더 노력을..!

---
**Today I Learend**
- 함수형 프로그래밍



---


### 함수형 프로그래밍

함수의 인자와 return값으로 함수를 넘겨받을 수 있는 프로그래밍



### 데이터 타입

메모리상에서 똑같은 값은 메모리 하나만을 차지한다. 
그래서 주소낭비를 하지 않는다. 

> 참조카운트에 대해서 자세히 알아보기

```javascript
var a;
a = "a";
a = "abcde";
```

참조형은 값으로 주소를 가지고 있으므로 기본형에 비해 한 단계 더 나아가므로 차이가 생기지 않는다

```javascript
var object = {
  a: 1,
  b: 'text',
}

object.a = 2;
```

참조카운트가 0이 되면, 즉 값을 참조하고 있는 대상이 몇개인지 세어서 참조하고 있는 값이 없으면 가비지 카운팅을 당한다.

```javascript
var object = {
  a: 1,
  arr: [3, 4],
}
object.arr = 'str';
```


### 화살표 함수

- `function` 생략
- 함수에 매개변수가 단 하나뿐이라면 괄호 생략
- 함수 바디의 표현식이 하나라면 중괄호와 `return` 생략 가능
- 화살표 함수는 항상 익명이다



### 비구조화 할당


### 비구조화 할당을 응용한 json 탐색법


```javascript


```


### 배열 메소드

| method | 설명 |
|---|---|
| push(), pop() | 스택(후입 선출) 생성 |
| unshift(), shift() | 큐(선입 선출) 생성 |
| concat() |요소 여러개를 배열 마지막에 추가하여 사본반환 |
| slice() | 배열 일부가 필요할 때 |
| splice() | 임의의 위치에 요소를  |
| slice() | 배열 일부를 사본반환 |
| copyWithin | 배열 안의 요소 교체 |
| fill | 배열 채우기 |
| reverse | 배열 역순으로 정렬 |
| sort | 배열 정렬 |

### 배열을 변형하는 메소드
| method | 설명 |
|---|---|
| map | 배열의 모든 요소를 변형 |
| filter | 조건에 맞는 요소들로만 새롭게 배열 생성 |
| reduce | 배열 전체를 다른 데이터 타입으로 변형할 때 |
| join | 요소를 문자열로 바꿔서 하나로 합칠 때 |



### 함수형 프로그래밍이 각광받는 이유

테라바이트급 데이터가 네트워크에서 떠다닌다면 모든 시스템이 다운되는 재앙에 가까운 일이 일어난다.
테라바이트급 데이터가 돌아다니면 네트워크는 다운된다.

어떤 데이터를 분석해야 할 경우가 생길 때 과거에 사용했던 구조는 클라이언트, 서버를 실행하는 코드가 서버쪽에 있었다.

약간의 인풋데이터만 전달하며, 기존의 데이터와 같이 사용을 해서 작업을 했다.

그런데, 데이터가 크다면(Big하다면..) 이동시켜서는 안된다. 
서버들은 저마다의 빅데이터를 가지고 있고...!
그러면 우리들은 실행가능한 코드를 보내야 한다.
코드는 기껏해야 kb이다...! mb급 용량은 되지도 않는다.

기존의 프로그래밍에서는 처리하기가 불가능하다.
함수라고 하는 것이 실제로..!
함수포인터를 넘겨주는 건데 그것은 결국 메모리 번지수이다.
메모리는 로컬한 자원이므로, 실행가능한 코드를 넘겨주는게 아니라서 게임이 안된다.


데이터를 보내는 시절이 아니라 코드를 보내야 하는 시절이므로..!(패러다임의 변화가 일어남)
60년대 사용했던 함수형 프로그래밍 언어가 다시금 등장했다.

요즘처럼 빅한 데이터를 보내는 시대는 함수형 프로그래밍 언어가 인기를 얻고 있다.

객체지향은 객체지향 나름대로 사용되는 영역이 있는 것이고
함수형은 빅데이터나 인공지능에서 사용되는 영역이 있다.
이처럼 언어의 패러다임은 시장의 요구에 의해 선택된다.


객체지향은 60년대에 개발되었다가...
컴퓨팅 파워가 안좋으니 각광받지 못했다.

그러나 요즘은 대부분의 서버 프로그램은 자바로 만든다.
이유는 컴퓨팅 파워가 많이 올라갔으므로..

아주 병목이 많이 생기는 영역들은 C로 코딩을 한다
엄청나게 컴퓨팅 파워를 요구하는 계산에는 C를 쓴다.


### JS 자료형
문자열, 전부다 문자열이다. "",'' 


### JS의 숫자!
자바스크립트라는 프로그래밍 언어는 태생적으로 정확한 수 계산을 위해서 만들어진 언어가 아니다. 그래서 숫자에 대해 정밀하고, 범용성이 높은 규격을 선택했다!

자바스크립트는 IEEE 754(아이트리플E 754)라는 규격을 따르고 있다
IEEE 754는 크기가 64비트이기 때문에 정밀한 값을 표현하는데 좋다. 다만 여기서 정밀하다는 것은 정확하다는 뜻이 아니다. 가령, 1.0과 1은 다르다. 1.0은 1에 아주 근사(근접)한 수이다. 

플로팅 포인트 넘버(floating point number), 부동소수점 숫자 = 정밀한 숫자!!   


#### 포인트 넘버(fixed point number)
픽스드 포인트 넘버(fixed point number) 즉, 고정소수점 숫자를 말한다.
정수는 항상 오른쪽에 소수점이 고정되어 있고, 소수부를 사용하지 않는다. 

#### 정확한 수는 계산할 때 사용한다!!

스탑워치는 정밀해야 한다. 달리기 시합 때 사용되는 스탑워치는 1000분의 1초까지 정밀하게 계산하지만 이 범위를 벗어난다면 오차를 허용한다. 

반면, 은행에서 돈의 계산은 정확해야 한다. 1원이라도 차이가 생기면 곤란하다. 은행은 오차를 허용하지 않는데, 은행에서 발생한 오차는 문제의 소지가 된다.

위의 예시를 통해서 정밀함과 정확함에 대해 이해할 수 있다.


